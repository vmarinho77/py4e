
Lists
=====

\index{list}
\index{type!list}

A list is a sequence
--------------------

Like a string, a *list* is a sequence of values. In a
string, the values are characters; in a list, they can be any type. The
values in list are called *elements* or sometimes
*items*.

\index{element}
\index{sequence}
\index{item}

There are several ways to create a new list; the simplest is to enclose
the elements in square brackets ("[" and "]"):

~~~~ {.python}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
~~~~

The first example is a list of four integers. The second is a list of
three strings. The elements of a list don't have to be the same type.
The following list contains a string, a float, an integer, and (lo!)
another list:

~~~~ {.python}
['spam', 2.0, 5, [10, 20]]
~~~~ 

A list within another list is *nested*.

\index{nested list}
\index{list!nested}

A list that contains no elements is called an empty list; you can create
one with empty brackets, `[]`.

\index{empty list}
\index{list!empty}

As you might expect, you can assign list values to variables:

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
~~~~

\index{assignment}

Lists are mutable
-----------------

\index{list!element}
\index{access}
\index{index}
\index{}
\index{bracket operator}
\index{operator!bracket}

The syntax for accessing the elements of a list is the same as for
accessing the characters of a string: the bracket operator. The
expression inside the brackets specifies the index. Remember that the
indices start at 0:

~~~~ {.python}
>>> print(cheeses[0])
Cheddar
~~~~

Unlike strings, lists are mutable because you can change the order of
items in a list or reassign an item in a list. When the bracket operator
appears on the left side of an assignment, it identifies the element of
the list that will be assigned.

\index{mutability}

~~~~ {.python .trinket}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print(numbers)
[17, 5]
~~~~

The one-th element of `numbers`, which used to be 123, is
now 5.

\index{index!starting at zero}
\index{zero, index starting at}

You can think of a list as a relationship between indices and elements.
This relationship is called a *mapping*; each index "maps
to" one of the elements.

\index{item assignment}
\index{assignment!item}

List indices work the same way as string indices:

-   Any integer expression can be used as an index.

-   If you try to read or write an element that does not exist, you get
    an `IndexError`.

\index{exception!IndexError}
\index{IndexError}

-   If an index has a negative value, it counts backward from the end of
    the list.

\index{list!index}
\index{list!membership}
\index{membership!list}
\index{in operator}
\index{operator!in}

The `in` operator also works on lists.

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
~~~~

Traversing a list
-----------------

\index{list!traversal}
\index{traversal!list}
\index{for loop}
\index{loop!for}
\index{statement!for}

The most common way to traverse the elements of a list is with a
`for` loop. The syntax is the same as for strings:

~~~~ {.python}
for cheese in cheeses:
    print(cheese)
~~~~

This works well if you only need to read the elements of the list. But
if you want to write or update the elements, you need the indices. A
common way to do that is to combine the functions `range` and
`len`:

\index{looping!with indices}
\index{index!looping with}

~~~~ {.python}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
~~~~

This loop traverses the list and updates each element. `len`
returns the number of elements in the list. `range` returns a
list of indices from 0 to $n-1$, where $n$ is the length of the list.
Each time through the loop, `i` gets the index of the next
element. The assignment statement in the body uses `i` to
read the old value of the element and to assign the new value.

\index{item update}
\index{update!item}

A `for` loop over an empty list never executes the body:

~~~~ {.python}
for x in empty:
    print('This never happens.')
~~~~

Although a list can contain another list, the nested list still counts
as a single element. The length of this list is four:

\index{nested list}
\index{list!nested}

~~~~ {.python}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
~~~~

List operations
---------------

\index{list!operation}

The `+` operator concatenates lists:

\index{concatenation!list}
\index{list!concatenation}

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
~~~~

Similarly, the `*` operator repeats a list a given number of times:

\index{repetition!list}
\index{list!repetition}

~~~~ {.python .trinket}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
~~~~

The first example repeats four times. The second example repeats the
list three times.

List slices
-----------

\index{slice operator}
\index{operator!slice}
\index{index!slice}
\index{list!slice}
\index{slice!list}

The slice operator also works on lists:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
~~~~

If you omit the first index, the slice starts at the beginning. If you
omit the second, the slice goes to the end. So if you omit both, the
slice is a copy of the whole list.

\index{list!copy}
\index{slice!copy}
\index{copy!slice}

~~~~ {.python}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
~~~~

Since lists are mutable, it is often useful to make a copy before
performing operations that fold, spindle, or mutilate lists.

\index{mutability}

A slice operator on the left side of an assignment can update multiple
elements:

\index{slice!update}
\index{update!slice}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
~~~~

List methods
------------

\index{list!method}
\index{method, list}

Python provides methods that operate on lists. For example,
`append` adds a new element to the end of a list:

\index{append method}
\index{method!append}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print(t)
['a', 'b', 'c', 'd']
~~~~

`extend` takes a list as an argument and appends all of the
elements:

\index{extend method}
\index{method!extend}

~~~~ {.python .trinket}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print(t1)
['a', 'b', 'c', 'd', 'e']
~~~~

This example leaves `t2` unmodified.

`sort` arranges the elements of the list from low to high:

\index{sort method}
\index{method!sort}

~~~~ {.python .trinket}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print(t)
['a', 'b', 'c', 'd', 'e']
~~~~

Most list methods are void; they modify the list and return
`None`. If you accidentally write `t = t.sort()`,
you will be disappointed with the result.

\index{void method}
\index{method!void}
\index{None special value}
\index{special value!None}

Deleting elements
-----------------

\index{element deletion}
\index{deletion, element of list}

There are several ways to delete elements from a list. If you know the
index of the element you want, you can use `pop`:

\index{pop method}
\index{method!pop}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print(t)
['a', 'c']
>>> print(x)
b
~~~~

`pop` modifies the list and returns the element that was
removed. If you don't provide an index, it deletes and returns the last
element.

If you don't need the removed value, you can use the `del`
operator:

\index{del operator}
\index{operator!del}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print(t)
['a', 'c']
~~~~

If you know the element you want to remove (but not the index), you can
use `remove`:

\index{remove method}
\index{method!remove}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print(t)
['a', 'c']
~~~~

The return value from `remove` is `None`.

\index{None special value}
\index{special value!None}

To remove more than one element, you can use `del` with a
slice index:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print(t)
['a', 'f']
~~~~

As usual, the slice selects all the elements up to, but not including,
the second index.

Lists and functions
-------------------

There are a number of built-in functions that can be used on lists that
allow you to quickly look through a list without writing your own loops:

~~~~ {.python .trinket}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print(len(nums))
6
>>> print(max(nums))
74
>>> print(min(nums))
3
>>> print(sum(nums))
154
>>> print(sum(nums)/len(nums))
25
~~~~

The `sum()` function only works when the list elements are
numbers. The other functions (`max()`, `len()`,
etc.) work with lists of strings and other types that can be comparable.

We could rewrite an earlier program that computed the average of a list
of numbers entered by the user using a list.

First, the program to compute an average without a list:

\VerbatimInput{../code3/avenum.py}

In this program, we have `count` and `total`
variables to keep the number and running total of the user's numbers as
we repeatedly prompt the user for a number.

We could simply remember each number as the user entered it and use
built-in functions to compute the sum and count at the end.

\VerbatimInput{../code3/avelist.py}

We make an empty list before the loop starts, and then each time we have
a number, we append it to the list. At the end of the program, we simply
compute the sum of the numbers in the list and divide it by the count of
the numbers in the list to come up with the average.

Lists and strings
-----------------

\index{list}
\index{string}
\index{sequence}

A string is a sequence of characters and a list is a sequence of values,
but a list of characters is not the same as a string. To convert from a
string to a list of characters, you can use `list`:

\index{list!function}
\index{function!list}

~~~~ {.python .trinket}
>>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s', 'p', 'a', 'm']
~~~~

Because `list` is the name of a built-in function, you should
avoid using it as a variable name. I also avoid the letter
"l" because it looks too much like the number "1".
So that's why I use "t".

The `list` function breaks a string into individual letters.
If you want to break a string into words, you can use the
`split` method:

\index{split method}
\index{method!split}

~~~~ {.python .trinket}
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> print(t)
['pining', 'for', 'the', 'fjords']
>>> print(t[2])
the
~~~~

Once you have used `split` to break the string into a list of
words, you can use the index operator (square bracket) to look at a
particular word in the list.

You can call `split` with an optional argument called a
*delimiter* that specifies which characters to use as
word boundaries. The following example uses a hyphen as a delimiter:

\index{optional argument}
\index{argument!optional}
\index{delimiter}

~~~~ {.python .trinket}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
~~~~

`join` is the inverse of `split`. It takes a list
of strings and concatenates the elements. `join` is a string
method, so you have to invoke it on the delimiter and pass the list as a
parameter:

\index{join method}
\index{method!join}
\index{concatenation}

~~~~ {.python .trinket}
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> delimiter.join(t)
'pining for the fjords'
~~~~

In this case the delimiter is a space character, so `join`
puts a space between words. To concatenate strings without spaces, you
can use the empty string, "", as a delimiter.

\index{empty string}
\index{string!empty}

Parsing lines
-------------

Usually when we are reading a file we want to do something to the lines
other than just printing the whole line. Often we want to find the
"interesting lines" and then *parse* the line to find
some interesting *part* of the line. What if we wanted to print out the
day of the week from those lines that start with "From "?

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
~~~~

The `split` method is very effective when faced with this
kind of problem. We can write a small program that looks for lines where
the line starts with "From ", `split` those lines, and then
print out the third word in the line:

\VerbatimInput{../code3/search5.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

The program produces the following output:

    Sat
    Fri
    Fri
    Fri
    ...

Later, we will learn increasingly sophisticated techniques for picking
the lines to work on and how we pull those lines apart to find the exact
bit of information we are looking for.

Objects and values
------------------

\index{object}
\index{value}

If we execute these assignment statements:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

we know that `a` and `b` both refer to a string,
but we don't know whether they refer to the *same* string. There are two
possible states:

\index{aliasing}

![Variables and Objects](height=0.5in@../images/list1)

In one case, `a` and `b` refer to two different
objects that have the same value. In the second case, they refer to the
same object.

\index{is operator}
\index{operator!is}

To check whether two variables refer to the same object, you can use the
`is` operator.

~~~~ {.python .trinket}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
~~~~

In this example, Python only created one string object, and both
`a` and `b` refer to it.

But when you create two lists, you get two objects:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
~~~~

In this case we would say that the two lists are
*equivalent*, because they have the same elements, but
not *identical*, because they are not the same object. If
two objects are identical, they are also equivalent, but if they are
equivalent, they are not necessarily identical.

\index{equivalence}
\index{identity}

Until now, we have been using "object" and "value" interchangeably, but
it is more precise to say that an object has a value. If you execute
`a = [1,2,3]`, `a` refers to a list object whose
value is a particular sequence of elements. If another list has the same
elements, we would say it has the same value.

\index{object}
\index{value}

Aliasing
--------

\index{aliasing}
\index{reference!aliasing}

If `a` refers to an object and you assign `b = a`,
then both variables refer to the same object:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
~~~~

The association of a variable with an object is called a
*reference*. In this example, there are two references to
the same object.

\index{reference}

An object with more than one reference has more than one name, so we say
that the object is *aliased*.

\index{mutability}

If the aliased object is mutable, changes made with one alias affect the
other:

~~~~ {.python}
>>> b[0] = 17
>>> print(a)
[17, 2, 3]
~~~~

Although this behavior can be useful, it is error-prone. In general, it
is safer to avoid aliasing when you are working with mutable objects.

\index{immutability}

For immutable objects like strings, aliasing is not as much of a
problem. In this example:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

it almost never makes a difference whether `a` and
`b` refer to the same string or not.

Listas como argumento
--------------

\index{list!as argument}
\index{argument}
\index{argument!list}
\index{reference}
\index{parameter}

Quando você passa uma lista como argumento de uma função, a função recebe uma referência dessa lista. Se a função modificar o parâmtro desta lista, o chamador verá a alteração. Por exemplo, remove_primeiro_elemento remove o primeiro elemento de uma lista:

~~~~ {.python}
def remove_primeiro_elemento(t)
	del t[0]
~~~~

Abaixo, é mostrado como ela é usada:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> remove_primeiro_elemento(letras)
>>> print(letras)
['b', 'c']
~~~~

O parâmetro `t` e a variável `letras` são aliases para o mesmo objeto.

É importante distinguir entre operações que modificam listas e operações que criam novas listas. Por exemplo, o método `append` modifica a lista, porém o operador `+` cria uma nova lista:

\index{append method}
\index{method!append}
\index{list!concatenation}
\index{concatenation!list}

~~~~ {.python .trinket}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print(t1)
[1, 2, 3]
>>> print(t2)
None

>>> t3 = t1 + [3]
>>> print(t3)
[1, 2, 3]
>>> t2 is t3
False
~~~~

A diferença é importante quando você escreve funções que supostamente modificam listas. Por exemplo, a função *does not* remove o início de uma lista:

~~~~ {.python}
def errado_remove_primeiro_elemento(t)
	t = t[1:]               #ERRADO!
~~~~

O operador 'slice' cria uma nova lista e a atribuição faz com que `t` se refira a essa, mas nenhuma dessas atribuições tem qualquer efeito sobre a lista passada como referência.

\index{slice operator}
\index{operator!slice}

Uma alternativa é escrever uma função que cria e retorna uma nova lista. Por exemplo, `calda` retorna todos, menos o primeiro elemento da lista:

~~~~ {.python}
def calda(t):
    return t[1:]
~~~~

A função não modifica a lista original. Aqui é mostrado como é usada:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> resto = tail(letras)
>>> print(resto)
['b', 'c']
~~~~

**Exercício 1: Escreva uma função chamada `corte` que recebe uma lista e a modifica, removendo o primeiro e o último elemento, e retorna `None`. Depois escreva uma função chamada `meio` que recebe uma lista e retorna uma nova lista que contém todos, menos o primeiro e o último elemento.**


Depuração
---------

\index{debugging}

Descuido com o uso de listas (e outros objetos mutáveis) pode levar a longa horas de depuração. Abaixo mostra algumas deslizes comuns e formas de evitá-las:

1. Não esqueça que a maioria do métodos de listas modifica o argumento e retorna  `None`. Isso é o oposto dos métodos das strings, que    retornam uma nova string e não modifica a string original. 

   Se você está acostumado a escrever código de string como este: 

    ~~~~ {.python}
    palavra.palavra.strip()
    ~~~~

   É tentador escrever um código de lista desta forma:

    ~~~~ {.python}
    t = t.sort()           # ERRADO!
    ~~~~

    \index{sort method}
    \index{method!sort}
    
   Como sort retorna None, a próxima operação que você executar com 't' provavelmente irá falhar.
    
    Antes de usar métodos de listas e operadores, você deve ler a documentação com cuidado e depois testar elas em um modo interativo. Os métodos e os operadores que as listas compartilham com outras sequência (como strings) são documentadas em:
    
    [docs.python.org/library/stdtypes.html#common-sequence-operations](https://docs.python.org/library/stdtypes.html#common-sequence-operations)
    
    Os métodos e operadores que são apenas aplicadas em sequências mutáveis são documentadas em:

    [docs.python.org/library/stdtypes.html#mutable-sequence-types](https://docs.python.org/library/stdtypes.html#mutable-sequence-types)

2.  Escolha um "idioma" e fique com ele.

    \index{idiom}
    Parte dos problemas, envolvendo listas, é que existem muitas maneiras para fazer coisas. Por exemplo, para remover um elemento de   uma lista, você pode usar o método `pop`, `remove`, `del`, ou simplesmente, utilizando a função `slice`.
    
    Para adicionar um elemento, você pode usar o método `append` ou o operador `+`. Porém, não esqueça que estas são as formas corretas de se fazer estes procedimentos:
    
    ~~~~ {.python}
    t.append(x)
    t = t + [x]
    ~~~~

    E essas, são as erradas:

    ~~~~ {.python}
    t.append([x])          # ERRADO!
    t = t.append(x)        # ERRADO!
    t + [x]                # ERRADO!
    t = t + x              # ERRADO!
    ~~~~
    
    Tente implementar esses exemplos em um modo interativo para ter certeza que você entende o que eles fazem. Note que apenas o último causa erro na compilação, os outros três são permitidos, porém não faz aquilo que é desejado.

3.  Faça cópias para evitar aliases.

    \index{aliasing!copying to avoid}
    \index{copy!to avoid aliasing}
    
    Se você quer usar o método 'sort' que modifica o argumento, porém também precisa manter a lista original intacta, você pode criar uma cópia.
 
    ~~~~ {.python}
    orig = t[:]
    t.sort()
    ~~~~
    Nesse exemplo, você também pode usar uma função existente chamada `sorted`, que retorna uma nova lista organizada e também mantém a  original intacta. Porém, nesse caso, você deve evitar usar `sorted` como um nome da variável!
   
4.  Listas, `split`, e arquivos
    
    Quando nós lemos e analisamos um arquivo, existem várias ocasiões em que a entrada pode causar falhas em nosso programa, então é uma boa ideia revisitar o padrão *guardião* quando se trata de escrever programas que lêem um arquivo e procuram por uma 'agulha no palheiro'.
    
    Vamos revisitar nosso programa que procura pelo dia da semana nas linhas de nosso arquivo:

    ~~~~
    From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
    ~~~~
    
    Como estamos quebrando essa linha em palavras, nós podemos dispensar o uso do método `startswith` e simplesmente procurar pela primeira palavra que determina se estamos interessados, de fato, nessa linha. Nós podemos usar `continue` para pular linhas que não têm "From" como sua primeira palavra:
    
    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    for linha in fhand:
        palavras = line.split()
        if palavras[0] != 'From' : continue
        print(palavras[2])
    ~~~~
    Isso parece ser bem mais simples, além que não precisamos do método `rstrip` para remover a quebra de linha no final do arquivo. Porém, qual o melhor?
   
    ~~~~
    python search8.py
    Sat
    Traceback (most recent call last):
        File "search8.py", line 5, in <module>
            if palavras[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~
    Isso funciona e vemos o dia a partir da primeira linha (Sat), mas o programa falha com `traceback error`. Então, o que deu errado? Por quê o nosso elegante, inteligente e "Phytonic" programa falhou?
   
    Você poderia encarar seu programa por um longo tempo, quebrar a cabeça tentando decifrá-lo, ou simplesmente pode pedir a ajuda de alguém. Porém a abordagem mais rápida e inteligente é adicionar uma linha de código `print`. O melhor lugar para adicionar essa instrução é logo antes da linha em que o programa falhou e pôr para imprimir na tela o dado que está causando falha.

    Essa abordagem pode gerar várias linha na saída, pelo menos, você terá, imediatamente, várias pistas sobre o problema em questão. Então, adicionamos um `print` da variável `letras` logo depois da linha cinco. Nós até adicionamos o prefixo "Depuração:" na linha, para podermos manter nossa saída regular separadas de nossa saída depurada.
    
    ~~~~ {.python}
    for linha in fhand:
        palavras = linha.split()
        print('Depuração:', palavras)
        if palavras[0] != 'From' : continue
        print(palavras[2])
    ~~~~
    
    Quando compilamos o programa, várias saídas são impressas na tela, porém, no final, vemos nossa saída de depuração e o erro para sabermos o que aconteceu logo antes da mensagem de erro.
    
    ~~~~
    Debug: ['X-DSPAM-Confidence:', '0.8475']
    Debug: ['X-DSPAM-Probability:', '0.0000']
    Debug: []
    Traceback (most recent call last):
      File "search9.py", line 6, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~
    
    Cada linha de depuração imprime uma lista de palavras que obtemos quando dividimos a linha em palavras. Se o programa der erro, a lista de palavras é vazia `[]`. Se abrimos o arquivo em um editor de texto e olharmos o mesmo, ele será exibido da seguinte maneira:

    ~~~~
    X-DSPAM-Result: Innocent
    X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
    X-DSPAM-Confidence: 0.8475
    X-DSPAM-Probability: 0.0000

    Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
    ~~~~
    
    O erro ocorre quando nosso programa encontra uma linha em branco. Claro que não existem palavras em uma linha em branco. Por quê não pensamos nisso quando estávamos escrevendo o código? Quando o código procura pela primeira palavra (`palavras[0]`) para checar se bate com "From", nós temos um erro de índice fora de alcance ("index out of range").
    
    Obviamente, esse é um local perfeito para adicionarmos algum código *guardião* para evitar a checagem da primeira palavra caso a mesma não esteja lá. Existem várias formas de proteger nosso código; nós iremos escolher checar o número de palavras que temos antes de olhar para a primeira palavra:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    contador = 0
    for linha in fhand:
        palavras = line.split()
        # print 'Debug:', words
        if len(palavras) == 0 : continue
        if palavras[0] != 'From' : continue
        print(palavras[2])

    ~~~~ 
    
    Primeiro, comentamos as linhas que imprimem a depuração, em vez de removê-las (caso nossa modificação falhe, e precisemos da depuração novamente). Depois, adicionamos uma declaração guardiã que checa se temos zero palavras, se sim, nós usamos "continue" para pular para próxima linha do arquivo.
    
    Podemos pensar nas duas declarações `continue` como um jeito de nos ajudar a refinar o conjunto de linhas que são interessantes para nós, e quais que queremos processar um pouco mais. Uma linha que não tem "From" como sua primeira palavra não é interessante para nós, então a pulamos.

    O programa modificado é executado com sucesso, então, talvez ele esteja correto. Nossa declaração guardiã nos dá a certeza que a `palavras[0]` nunca irá falhar, porém, talvez isso não seja suficiente. Quando estamos programando, nós devemos sempre estar pensando, "O que pode acontecer de errado?" 

**Exercício 2: Descubra qual linha do programa acima não está devidamente protegida. Veja se você pode construir um arquivo de texto que causa falha no programa e depois modifique o programa para que a linha seja propriamente protegida e por fim, teste o programa para ter certeza que ele manipula o novo arquivo de texto.**

**Exercício 3: Reescreva o código guardião nos exemplos acima sem duas declarações `if`. Em vez disso, use uma expressão lógica composta usando o operador lógico `and`, com uma única declaração `if`.**

Glossario
--------
aliase
: Circunstância onde duas ou mais variáveis se referem ao mesmo objeto.
\index{aliasing}

delimitador
: Caractere ou string usado para indicar onde a string deve ser dividida
\index{delimiter}

elemento
: Um dos valores em uma lista (ou outra sequência); também chamada de itens.
\index{element}

equivalente
: Ter o mesmo valor 
\index{equivalent}

índice
: Um valor inteiro que indica um elemento da lista
\index{index}\index{}

idêntico
: Ser o mesmo objeto (o que implica em equivalência)
\index{identical}

lista
: Uma sequência de valores
\index{list}

lista de passagem
: O acesso sequencial sobre cada elemento da lista
\index{list!transversal}

lista aninhada
: Uma lista que é um elemento de uma outra lista.
\index{nested list}

objeto
: Algo que uma variável pode se referir. Um objeto tem um tipo e um valor.
\index{object}

referência
: Associação entre variável e seu valor
\index{reference}

Exercícios
---------

\index{Romeo and Juliet}

**Exercicio 4: Baixe a copia do arquivo 
[**www.py4e.com/code3/romeo.txt**](http://www.py4e.com/code3/romeo.txt)**.
Escreva um programa para abrir o arquivo chamado romeo.txt e leia-o linha por linha. Para cada linha, separe-a em uma lista de palavras usando a função `split`. Para cada palavra, cheque se esta palavra já existe na lista. Caso não exista, adicione ela. Quando o programa terminar de verificar, ordene e imprima estas palavras em ordem alfabética.**

~~~~
Digite o nome do arquivo: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already',
'and', 'breaks', 'east', 'envious', 'fair', 'grief',
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft',
'sun', 'the', 'through', 'what', 'window',
'with', 'yonder']
~~~~

**Exercício 5: Escreva um programa que leia uma caixa de email, e quando você encontrar uma linha que comece com "From", você vai partir a linha em palavras usando a função `split`. Nós estamos interessados em quem envia a mensagem, o que é a segunda palavra na linha que começa com From.**

~~~~
From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
~~~~

**Você vai analisar a linha que começa com From e irá pôr para imprimir na tela a segunda palavra (para cada linha do tipo) depois o programa também deverá contar o número de linhas que começam com From e imprimir em tela o valor final desse contador. Esse é um bom exemplo da saída com algumas linhas removidas:**

~~~~
python fromcount.py
Digite o nome do arquivo: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
~~~~

**Exercício 6: Reescreva o programa que solicita o usuário uma lista de números e que depois imprime em tela o maior número e o menor número quando o usuário digitar a palavra "feito". Escreva um programa para armazenar as entradas do usuário em uma lista e use as funções `max()` e `min()` para computar o número máximo e o mínimo depois que o loop for completo.**

~~~~
Digite um número: 6
Digite um número: 2
Digite um número: 9
Digite um número: 3
Digite um número: 5
Digite um número: feito
Maximo: 9.0
Minimo: 2.0
~~~~
